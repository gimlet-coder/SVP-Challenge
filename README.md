# C++によるSVPチャレンジ実装

[![Textbook](https://img.shields.io/badge/Reference-格子暗号解読-blue.svg)](https://amzn.asia/d/40cFynK)

C++を用いて、教科書『[格子暗号解読 ―SVPチャレンジ・LWEチャレンジ ―](https://amzn.asia/d/40cFynK)』を参考にしながら最短ベクトル問題(SVP)チャレンジに取り組むリポジトリです。

---

## 1. 概要

格子暗号解読の基礎となるSVP（Shortest Vector Problem）の求解アルゴリズムをC++で実装することを目標としています。



---

## 2. 実行結果とアルゴリズムの進化

### 1. 初期実装の限界と剪(せん)定の導入 (n=40, β=20)
* **枝刈りなし (限界)**: 

    約90分（探索ノード数 $1.06 \times 10^{10}$）を費やしたが、実用的な時間内で計算がまともに終了せず、この手段での限界を確認。
* **線形枝刈り (Linear Pruning) の実装**: 

    枝刈り導入後、実行時間は **64.223秒** に劇的に短縮され、到達ノルムも $10^{40}$ から $10^{6}$ へと大幅に改善。これにより、枝刈りが高次元格子基底簡約において必須の技術であることを確認した。

---

### 2. Progressive BKZ による 50次元 SVP 達成
| パラメータ | 設定値 |
| :---: | :---: |
| **次元 n** | 50 |
| **ブロックサイズ β** | 20 → 50 (少しずつ増加させる (Progressive))|
| **最短ノルム (達成)** | **1472.19** (現状の50次元における世界レコードと同じ値)|
| **総実行時間** | 1217.00秒 (約20分) |

* **戦略**: Progressive BKZ を採用し、ブロックサイズ $\beta$ を20から50まで段階的に増やすことで、計算資源を効率的に配分した。
* **成果**: スタンダードな LLL と DeepLLL を戦略的に組み合わせ、現状の50次元のレコード記録を出したシード値を用いた結果、50次元のSVPチャレンジの Hall of Fame 記録（**1472**）を比較的短時間で達成した。

---

### 3. アルゴリズムにおける最終的な改良ポイント:
* **LLLとDeepLLLのハイブリッド導入**: 
* 初期計算のボトルネック解消を目指し、 **LLL($\delta = 0.75$)** による高速な整地と**DeepLLL($\delta = 0.999$) による高精度な簡約** のハイブリッド構造を採用。これにより、初期簡約の品質を保ちながら高速化に成功した。
* **$\beta$ 増分ロジック** 計算コストが増大することが予想される $\beta \ge 25$ 以降は、増分を $+3$ や $+5$ と調整した。これにより、計算時間削減と最短ベクトル発見のバランスを図った。


---


## 3. プロジェクトの目的

* **SVPおよび関連アルゴリズムの理解:**
    * グラム・シュミットの直交化
    * LLL (Lenstra–Lenstra–Lovász) アルゴリズム
    * DeepLLL / MLLL アルゴリズム
    * BKZ アルゴリズム
* **C++による数値計算・アルゴリズム実装能力の向上**
* **Git/GitHubを用いたバージョン管理の実践**

---

## 4. 使用技術

* **言語:** C++ (C++17)
* **コンパイラ:** g++ (MSYS2 UCRT64 環境推奨)
* **ライブラリ:** **Eigen** (行列演算), **Boost** (多倍長演算)

---

## 5. 実装済み機能

* `Gram_Schmidt.cpp`: グラム・シュミットの直交化
* `lagrange_basis_reduction.cpp`: ラグランジュの基底簡約アルゴリズム
* `Size-reduce.cpp`: サイズ基底簡約アルゴリズム
* `LLL.cpp`: LLL基底簡約アルゴリズム 
* `DeepLLL.cpp`: DeepLLL基底簡約アルゴリズム
* `MLLL.cpp`: MLLL基底簡約アルゴリズム
* `ENUM.cpp`: 格子上の最短ベクトルの数え上げ
* `BKZ.cpp`: BKZ基底簡約アルゴリズム
* `DeepBKZ.cpp`: DeepBKZ基底簡約アルゴリズム
* `Progressive_BKZ.cpp`: Progressive_BKZ基底簡約アルゴリズム
* `scanning_lattice.cpp`: ファイルから直接行列を受け取るプログラム (SVPチャレンジのジェネレーターにも対応)

**Upgrade**
- 多倍長浮動小数対応
    → 高次元･高精度の格子基底簡約を正確に実行可能
- ENUMの探索アルゴリズムに線形な枝刈りを追加
---
## 6. 実行方法

本プロジェクトは MSYS2 UCRT64 環境でのビルドを前提としています。

1.  **依存ライブラリのインストール**
    
    格子計算の精度向上のため、Eigen に加えて Boost をインストールする必要があります。

    MSYS2の 「UCRT64」 ターミナルを開き、以下のコマンドでライブラリをインストールしてください。 
    (※従来のMinGW64版とはパッケージ名が異なりますのでご注意ください)
    
    ```bash
    # Eigen (行列演算), Boost (ユーティリティ) をインストール
    pacman -S mingw-w64-ucrt-x86_64-eigen3 mingw-w64-ucrt-x86_64-boost
    # GMP (任意精度整数) と MPFR (任意精度浮動小数点数) をインストール
    pacman -S mingw-w64-ucrt-x86_64-gmp mingw-w64-ucrt-x86_64-mpfr
    ```

2.  **ライブラリパスの設定(必要に応じて)**
    Makefile はデフォルトで C:/msys64/ucrt64/include/... を参照するように設定されています。 MSYS2を標準的な場所にインストールしている場合、編集は不要です。

    もし異なる場所にインストールしている場合は、Makefile 内の以下の行を環境に合わせて書き換えてください。

    ```Makefile
    EIGEN_PATH = C:/(各々の環境に応じて編集)/eigen3
    BOOST_PATH = C:/(各々の環境に応じて編集)/include
    ```

3.  **リポジトリのクローン**
    
    ```bash
    git clone [https://github.com/gimlet-coder/SVP-Challenge.git](https://github.com/gimlet-coder/SVP-Challenge.git)
    cd SVP-Challenge
    ```

4.  **コンパイル**
    ターミナル (PowerShell または MSYS2) で以下のコマンドを実行します。

    ```bash
    # コンパイル (Makefileが自動的に処理します)
    make

    # 'make' コマンドが見つからないと言われた場合
    mingw32-make
    ```

5.  **実行**
    コンパイルが成功すると、フォルダ内に svp_solver.exe が生成されます。 以下のコマンドで実行してください。
    ```bash
    ./svp_solver.exe
    ```
---

6. **クリーンアップ(任意)**
    生成された実行ファイル (.exe) やオブジェクトファイル (.o) を削除する場合は、以下のコマンドを実行します。
    ```bash
    make clean
    # (または mingw32-make clean)
    ```

## 7. 更新予定
* [ ] ベクトル計算の効率化
* [ ] 100次元程度のSVPチャレンジに挑戦
* [ ] プログラムの並列化実装

---

